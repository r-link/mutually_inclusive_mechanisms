###############################################################################
#
#    Fitting of vulnerability curves
#
#    Script: Roman Link (roman.link@plant-ecology.de)	
#
###############################################################################

# This script fits the vulnerability curves to the dataset of flow-centrifuge 
# measurements from a subsample of all diffuse-porous trees.

# 1. Load packages ------------------------------------------------------------
# if pacman is not installed, install via install.packages("pacman").
# the package manager will take care of the installation of all subsequent 
# packages.
pacman::p_load(readxl, tidyverse)

# 2. Read vulnerability curve data --------------------------------------------
vc <- read_xlsx("data/IDENT_VC_raw_data_unified.xlsx", sheet = 2)
vc

# 3. Define self-starting function for models of vulnerability curves ---------
# Logistic model by Pammenter & Vander Willigen (1998) in the modified version
# based on conductivity (cf. Ogle et al. 2009)

# define function for starting values
init_Kpamm <- function(mCall, data, LHS, control = NULL, trace = NULL) {
  # extract K and psi and calculate approximate fraction loss of conductivity
  # for starting values
  K   <- data[[1]]
  psi <- data[[2]]
  flc <- (1 - K/max(K)) * 0.98 + 0.01
  
  # fit lm for starting values
  cc    <- coef(lm(qlogis(flc) ~ psi))
  
  # return starting values
  pars <- c(max(K), -cc[2] * 25, -cc[1]/cc[2])
  setNames(pars, nm = mCall[c("Kmax", "slope", "p50")])
}

# define self starting function
SS_Kpamm <- selfStart(
  model =  ~ Kmax * (1 - 1 / (1 + exp(slope / 25 * (x - p50)))),
  initial = init_Kpamm,
  parameters = c("Kmax", "slope", "p50")
)

# 4. define function for tidy model output ------------------------------------
# helper function for standard errors and confidence intervals
se95 <- function(x) c(SE = sd(x), # no mistake!the standard error of the
                                  # estimate is the SD of the sample
                      lower = as.numeric(quantile(x, .025)), 
                      upper = as.numeric(quantile(x, .975)))

# summary function that returns parameter estimates with approximate
# confidence intervals based on sampling from the variance-covariance matrix
tidyfun <- function(model){
  # get parameter estimates
  coefs <- coef(model)
  
  # append p12 and p88
  coefs1 <- c(coefs, 
              p12 = 25 * log(100/12 - 1) / coefs["slope"] + coefs["p50"], 
              p88 = 25 * log(100/88 - 1) / coefs["slope"] + coefs["p50"])
  
  # get variance-covariance matrix 
  covmat <- vcov(model)
  
  # compute 10000 bootstrap samples based on multivariate normal distribution
  # with the model covariance matrix
  samp <- MASS::mvrnorm(100000, mu = coefs, Sigma = covmat) %>% 
    as.data.frame()
  
  # calculate confidence intervals, unite and return
  samp %>% 
    mutate(p12 = 25 * log(100/12 - 1) / slope + p50,
           p88 = 25 * log(100/88 - 1) / slope + p50) %>% 
    apply(2, se95) %>% 
    t() %>% 
    as.data.frame() %>% 
    mutate(term = row.names(.),
           est  = coefs1) %>% 
    select(term, est, SE, lower, upper)
}

# 4. Test functionality for a single curve ------------------------------------
# get subset of dataset for a single curve
data <- filter(vc, sample_id == unique(sample_id)[6])

# plot
plot(K ~ psi, data)

# fit model
m1 <- nls(K ~ SS_Kpamm(psi, Kmax, slope, p50), data = data)

# inspect model summary
summary(m1)

# plot model predictions
lines(predict(m1) ~ data$psi) 

# get tidy model summary
tidyfun(m1)


# 5. Fit vulnerability curves for all samples ---------------------------------
# use purrr::map on grouped data to compute curves and parameter estimates for
# all models
models <- vc %>% 
  group_nest(species, sample_id) %>% # group and nest dataset for each sample
  mutate(model  = map(data, ~ nls(K ~ SS_Kpamm(psi, Kmax, slope, p50), data = .x)),
         output = map(model, tidyfun) 
  ) 
models

# 6. Export model output ------------------------------------------------------
# prepare output table
output <- models %>% 
  select(-data, -model) %>% 
  unnest(output) %>% 
  set_names(tolower(names(.)))
output

# export as csv
write.csv(output, "output/IDENT_VC_parameters.csv", row.names = FALSE)



